<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <title>Wallpaper generator</title>
  <style media="screen">
    body{
      background-color: rgb(10,50,40);
      color: rgb(200, 200, 200);
      font-size: 40px;
      overflow: hidden;
      font-size: 300%;
    }
    canvas{
      position: absolute;
      left: 0;
      top: 0;
      outline: 2px dashed navy;
      cursor: pointer;
    }
  </style>
  <link href="../css/style.css" rel="stylesheet">
</head>
<body>
  <canvas id="canvas" width="300" height="300"></canvas>
  <script type="text/javascript">
    "use strict";

    function rand(max=1) {
      return Math.random()*max;
    }
    function rand0(max=1) {
      return (Math.random()-0.5)*max;
    }
    function randInt(max=2) {
      return Math.floor(Math.random()*max);
    }
    function randProb(p=0.5) {
      return p>Math.random();
    }
    function randRange(a, b) {
      return Math.random()*(b-a)+a;
    }
    function clamp(num, val=1) {//num to clamp, special value
      return 1-(val/(num+val));
    }
    function colorLerp(x, n1, n2) {
      return n2.sub(n1).mult(x).add(n1);
    }
    function cutoff(x, min, max) {
      if (min!=undefined && x<min) {
        return min;
      }
      if (max!=undefined && x>max) {
        return max;
      }
      return x;
    }
    function closenessPenalty(x, coefficient) { //what number to divide x by for to not reach 1
      return 1-coefficient-coefficient/(x-1);
    }
    function round(v, p=2) {
      return Math.round(v*10**p+Number.EPSILON)/10**p;
    }
    function lerp(x, v1, v2) {
      return x*(v2-v1)+v1;
    }
    function map(x, a1, a2, b1, b2) {
      return (x-a1)/(a2-a1)*(b2-b1)+b1;
    }
    function arrayContains(arr, val) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i]==val) return true;
      }
      return false;
    }

    var canvas=document.getElementById("canvas");
      var context=canvas.getContext("2d");
      var TAU=2*Math.PI;
      var PI=Math.PI;
      var HPI=Math.PI/2;
      var PHI=(Math.sqrt(5)+1)/2;
      var loops=0;
      var paused=false;
      var frameskip=1;
      var keys=[];
      var height=100;

    function Color(r=255, g=0, b=255, a=1) {
      this.r=r;
      this.g=g;
      this.b=b;
      this.a=a;
      this.copy=function() {
        return new Color(this.r, this.g, this.b, this.a);
      }
      this.each=function(f) {
        return new Color(f(this.r), f(this.g), f(this.b));
      }
      this.modify=function(amp) {
        return this.each(function(n) {
          var x=n+rand0(amp);
          if (x>255) {
            return 255;
          }
          else if (x<0) {
            return 0;
          }
          else {
            return x;
          }
        });
      }
      this.add=function(v) {
        return new Color(this.r+v.r, this.g+v.g, this.b+v.b);
      }
      this.lighten=function(v) {
        return new Color(v*(256-this.r)+this.r, v*(256-this.g)+this.g, v*(256-this.b)+this.b);
      }
      this.sub=function(v) {
        return new Color(this.r-v.r, this.g-v.g, this.b-v.b);
      }
      this.mult=function(v) {
        return new Color(this.r*v, this.g*v, this.b*v);
      }
      this.rgb=function() {
        return "rgb("+this.r+","+this.g+","+this.b+")";
      }
      this.square=function() {
        return new Color(this.r**2, this.g**2, this.b**2, this.a);
      }
      this.sqrt=function() {
        return new Color(Math.sqrt(this.r), Math.sqrt(this.g), Math.sqrt(this.b), this.a);
      }
    }
    function ColorFromHex(hex) { //from https://stackoverflow.com/a/5624139/10630826 on 26.12.2021
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
          return r + r + g + g + b + b;
        });

        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? new Color(
          parseInt(result[1], 16),
          parseInt(result[2], 16),
          parseInt(result[3], 16)
        ) : null;
      }
    function Gradient(v) {
      this.colors=[];
      this.values=[];
      for (var i = 0; i < v.length; i+=2) {
        this.colors[i/2]=v[i];
        this.values[i/2]=v[i+1];
      }
      this.get=function(x) {
        for (var i = 0; i < this.values.length; i++) {
          if (this.values[i]>x) {
            if (i==0) {
              return this.colors[0].copy();
            }
            else {
              // return this.colors[i].sub(this.colors[i-1]).mult((x-this.values[i-1])/(this.values[i]-this.values[i-1])).add(this.colors[i-1]); // simple, ugly mixing
              return this.colors[i].square().sub(this.colors[i-1].square()).mult((x-this.values[i-1])/(this.values[i]-this.values[i-1])).add(this.colors[i-1].square()).sqrt(); // complicated, expesive, prettier mixing
            }
          }
        }
        return this.colors[this.colors.length-1].copy();
      }
    }
    if (true) {//colors and color gradients used
      var colors={
        mist: new Color(110, 130, 210),
        sky: new Color(50, 150, 210),
        darkBrown: new Color(40, 17, 2),
        lightBrown: new Color(200, 160, 60),
        sand: new Color(200, 170, 120),

        white: new Color(255, 255, 255),
        black: new Color(0, 0, 0),
        red: new Color(255, 0, 0),
        green: new Color(0, 255, 0),
        blue: new Color(0, 0, 255),
        yellow: new Color(255, 255, 0),
        magenta: new Color(255, 0, 255),
        cyan: new Color(0, 255, 255),

        darkRed: new Color(127, 0, 0),
        darkGreen: new Color(0, 127, 0),
        darkBlue: new Color(0, 0, 127),
        darkYellow: new Color(127, 127, 0),
        darkMagenta: new Color(127, 0, 127),
        darkCyan: new Color(0, 127, 127),
        veryDarkRed: new Color(63, 0, 0),
        veryDarkGreen: new Color(0, 63, 0),
        veryDarkBlue: new Color(0, 0, 63),
        veryDarkYellow: new Color(63, 63, 0),
        veryDarkMagenta: new Color(63, 0, 63),
        veryDarkCyan: new Color(0, 63, 63),

        orange: new Color(255, 127, 0),
        gray: new Color(127, 127, 127),
        darkGray: new Color(63, 63, 63),
        darkGray: new Color(63, 63, 63),
        slate: new Color(50, 67, 127)
        // brown: new Color(64, 32, 0)
      }

      var style = window.getComputedStyle(document.body)
      var themeColors = {
        BG: ColorFromHex(style.getPropertyValue('--bg-color')),
        secondaryBG: ColorFromHex(style.getPropertyValue('--secondary-bg-color')),
        beyondBG: ColorFromHex(style.getPropertyValue('--beyond-bg')),
        main: ColorFromHex(style.getPropertyValue('--main-color')),
        highlights: ColorFromHex(style.getPropertyValue('--highlights')),
        framing: ColorFromHex(style.getPropertyValue('--framing')),
        subtler: ColorFromHex(style.getPropertyValue('--subtler')),
        subtleTinted: ColorFromHex(style.getPropertyValue('--subtle-tinted')),
      }
      var gradients={
        leafy: new Gradient([colors.veryDarkGreen, 0, colors.green, 0.5, colors.yellow, 1]),
        rainbow: new Gradient([colors.black, 0, colors.red, 0.1, colors.yellow, 0.26, colors.green, 0.42, colors.cyan, 0.58, colors.blue, 0.74, colors.magenta, 0.9, colors.white, 1]),
        natural: new Gradient([colors.black, 0, colors.green, 0.6, colors.yellow, 0.8, colors.white, 0.9, colors.red, 1]),
        tech: new Gradient([colors.black, 0, colors.darkBlue, 0.3, colors.cyan, 0.6, colors.white, 1]),
        flame: new Gradient([colors.black, 0, colors.darkBlue, 0.1, colors.white, 0.24, colors.yellow, 0.38, colors.red, 0.7, colors.black, 1]),
        middleBand: new Gradient([colors.black, 0.4, colors.white, 0.401, colors.white, 0.599, colors.black, 0.6]),
        middleNarrowBand: new Gradient([colors.white, 0.47, colors.black, 0.472, colors.black, 0.528, colors.white, 0.53]),
        blendingTest: new Gradient([colors.green, 0, colors.red, 1]),
        theme: new Gradient([themeColors.framing, 0, themeColors.BG, 0.4, themeColors.BG, 0.6, themeColors.highlights, 0.8, themeColors.main, 1]),
      }

      var useGradient=gradients.theme;
    }

    function Vec2(x=0, y=0) {
      this.x=x;
      this.y=y;
      this.copy=function() {
        return new Vec2(this.x, this.y);
      }
      this.add=function(v1, v2) {// FIXME: doesn't always work with both values
        if (v2) {
          return new Vec2(this.x+v1, this.y+v2);
        }
        return new Vec2(this.x+v1.x, this.y+v1.y);
      }
      this.sub=function(v) {
        return new Vec2(this.x-v.x, this.y-v.y);
      }
      this.mult=function(n) {
        return new Vec2(this.x*n, this.y*n);
      }
      this.div=function(n) {
        return new Vec2(this.x/n, this.y/n);
      }
      this.dot=function(v) {
        return v.x*this.x + v.y*this.y;
      }
      this.iHatLanding=function(v) {
        return new Vec2(v.x*this.x-v.y*this.y, v.x*this.y+v.y*this.x);
      }
      this.len=function() {
        return Math.sqrt(this.x**2+this.y**2);
      }
      this.dist=function(v) {
        return Math.sqrt((this.x-v.x)**2+(this.y-v.y)**2);
      }
      this.sqDist=function(v) {
        return (this.x-v.x)**2+(this.y-v.y)**2;
      }
      this.unit=function() {
        var len=Math.sqrt(this.x**2+this.y**2);
        return new Vec2(this.x/len, this.y/len);
      }
      this.dir=function() {//angle to x axis in radians
        return Math.atan2(this.y, this.x);
      }
      this.taxi=function() {//taxicab distance length
        return this.x+this.y;
      }
      this.screen=function() {//coordinates for drawing
        return new Vec2(this.x*height, this.y*height);
      }
    }

    function quickVec2TopLeftSquare(p, width=4, color=colors.yellow) {
      context.fillStyle=color.rgb() || color;
      context.fillRect(p.x, p.y, width, width);
    }

    function smootherStep(x) {
      return x * x * x * (x * (x * 6 - 15) + 10);
    }
    function getSmoothWeightedAverage(x, v1=0, v2=1) {//lerp, but with smootherstep
      return x * x * x * (x * (x * 6 - 15) + 10)*(v2-v1)+v1;
    }
    function getWeightedSquareAverage(x, y, v1, v2, v3, v4) {//smooth interpolation
      return getSmoothWeightedAverage(y, getSmoothWeightedAverage(x, v1, v2), getSmoothWeightedAverage(x, v3, v4));
    }
    function getNoise(i, j, seed=0) {//perlin noise
      var fi=Math.floor(i);
      var fj=Math.floor(j);
      var reli=i-fi;
      var relj=j-fj;
      function getCurrentDot(iOff, jOff) {
        var ang=((fi+iOff)*2+((fj+jOff+seed)*(seed+1))**2)**2;
        // var ang=((fi+iOff)+(fj+jOff)*2)**2;
        return Math.cos(ang)*(reli-iOff)+Math.sin(ang)*(relj-jOff);
      }
      return getWeightedSquareAverage(reli, relj, getCurrentDot(0, 0), getCurrentDot(1, 0), getCurrentDot(0, 1), getCurrentDot(1, 1))*0.8591+0.5;
    }

    resize();
    var globSeed=rand(10)+1;
    var pixSize=5;
    // var pixSize=14;
    var gridWidth=canvas.width/pixSize; var gridHeight=canvas.height/pixSize;
    var grid=[];
    var outlineBoundary=0.5;

    function drawPixel(i, j) {
      if (i>=0 && i<gridWidth && j>=0 && j<gridHeight) {
        // var i=Math.floor(i); var j=Math.floor(j);
        var i=Math.floor(i); var j=Math.floor(j);

        // var aboveBoundaryTotal=0;
        // var aboveBoundary1Total=0;
        // var aboveBoundary2Total=0;
        // if (i>=0 && i<gridWidth-1 && j>=0 && j<gridHeight-1) {
        //   // aboveBoundaryTotal=
        //   //   (grid[i][j]>outlineBoundary) +
        //   //   (grid[i+1][j]>outlineBoundary) +
        //   //   (grid[i][j+1]>outlineBoundary) +
        //   //   (grid[i+1][j+1]>outlineBoundary)
        //
        //   aboveBoundary1Total=
        //     (grid[i][j]>0.38) +
        //     (grid[i+1][j]>0.38) +
        //     (grid[i][j+1]>0.38) +
        //     (grid[i+1][j+1]>0.38)
        //   aboveBoundary2Total=
        //     (grid[i][j]>0.62) +
        //     (grid[i+1][j]>0.62) +
        //     (grid[i][j+1]>0.62) +
        //     (grid[i+1][j+1]>0.62)
        // }

        // if (randProb(0.01)) {
        //   console.log(aboveBoundaryTotal);
        // }

        // console.count("aBT:"+aboveBoundaryTotal)

        // var c=colorLerp(grid[i][j], colors.black, colors.white);
        // quickVec2TopLeftSquare(
        //   new Vec2(i*pixSize, j*pixSize),
        //   pixSize,
        //   c
        // )

        var value=grid[i][j]

        value = getSmoothWeightedAverage(Math.min(1, 3*j/gridHeight), 0.5, value)
        // context.fillStyle="hsl(0,0%,"+grid[i][j]*100+"%)";//grayscale values
        context.fillStyle=useGradient.get(value).rgb();//gradient of values
        // context.fillStyle=(aboveBoundaryTotal==2 || aboveBoundaryTotal==3) ? colors.black.rgb() : colors.white.rgb();//pixel outline
        // context.fillStyle=(aboveBoundary1Total==2||aboveBoundary1Total==3||aboveBoundary2Total==2||aboveBoundary2Total==3) ? colors.black.rgb() : colors.white.rgb();//pixel outline
        context.fillRect(i*pixSize, j*pixSize, pixSize, pixSize);
      }
    }

    function initialiseGrid() {
      for (var i = 0; i < gridWidth; i++) {//populate grid with perlin noise
        grid[i]=[];
        for (var j = 0; j < gridHeight; j++) {
          grid[i][j]=getNoise(i*pixSize/30, j*pixSize/30, globSeed);
        }
      }
    }

    function attemptGridRead(i, j, curGrid=grid) {
      if (i>=0 && i<curGrid.length && j>=0 && j<curGrid[0].length) {
        return curGrid[Math.floor(i)][Math.floor(j)];
      }
    }
    function attemptGridWrite(val, i, j, curGrid=grid) {
      if (val!=undefined && !isNaN(val) && i>=0 && i<curGrid.length && j>=0 && j<curGrid[0].length) {
        curGrid[Math.floor(i)][Math.floor(j)]=val;
      }
    }
    var newGrid=[];
    function gridToNewGrid() {
      newGrid=[];
      for (var i = 0; i < grid.length; i++) {
        newGrid[i]=[];
        for (var j = 0; j < grid[i].length; j++) {
          newGrid[i][j]=grid[i][j];
        }
      }
    }

    if (true) {//rule definition
      var ruleInitialFuncs={
        phyllotaxis: function(rule) {
          rule.minI=Math.max(-rule.ruleSize/2, -rule.x);
          rule.maxI=Math.min(rule.ruleSize/2, gridWidth+1-rule.x);
          rule.minJ=Math.max(-rule.ruleSize/2, -rule.y);
          rule.maxJ=Math.min(rule.ruleSize/2, gridHeight+1-rule.y);
          rule.rotationTrig=[];
          for (var i = -10; i <= 10; i++) {
            rule.rotationTrig.push([Math.cos(rule.angle*i), Math.sin(rule.angle*i)]);
          }
          return rule;
        },
        rotation: function(rule) {
          rule.minI=Math.max(-rule.ruleSize/2, -rule.x);
          rule.maxI=Math.min(rule.ruleSize/2, gridWidth+1-rule.x);
          rule.minJ=Math.max(-rule.ruleSize/2, -rule.y);
          rule.maxJ=Math.min(rule.ruleSize/2, gridHeight+1-rule.y);
          rule.rotationTrig=[];
          for (var i = 0; i < rule.sectors; i++) {
            rule.rotationTrig.push([Math.cos(TAU*i/rule.sectors), Math.sin(TAU*i/rule.sectors)]);
          }
          return rule;
        }
      }
      var enforceFuncs={
        phyllotaxis: function() {
          // gridToNewGrid();
          var newGrid=[];//optimise this too
          for (var i = 0; i < this.ruleSize; i++) {
            newGrid[i]=[]
            for (var j = 0; j < this.ruleSize; j++) {
              newGrid[i][j]=undefined;
            }
          }

          // for (var i = -this.ruleSize/2; i < this.ruleSize/2; i++) {
          //   for (var j = -this.ruleSize/2; j < this.ruleSize/2; j++) {
          for (var i = this.minI; i < this.maxI; i++) {
            for (var j = this.minJ; j < this.maxJ; j++) {
              // TODO: check if in screen bounds (?)
              // if (i**2+j**2<=(this.ruleSize/2)**2 && this.x+i>=0 && this.x+i<gridWidth+1 && this.y+j>=0 && this.y+j<gridHeight+1) {
              if (i**2+j**2<=(this.ruleSize/2)**2) {
                // var curAng=Math.atan2(j, i)+PI;
                var curAng=Math.atan2(j, i);
                var curLen=Math.sqrt(i**2+j**2);
                // if ((this.phase+TAU/this.sectors<=TAU)?//only do averaging for one sector
                //   (curAng>this.phase && curAng<=this.phase+TAU/this.sectors):
                //   (curAng>this.phase || curAng<=this.phase+TAU/this.sectors-TAU)
                //   ) {

                var runningTotal=0; var runningWeight=0;
                // for (var leaf = 0; leaf < this.sectors; leaf++) {
                // for (var leaf = -10; leaf < 10; leaf++) {
                for (var rot=0; rot < this.rotationTrig.length; rot++) {
                  var curPos=new Vec2(
                    // this.x+Math.cos(curAng+this.angle*leaf)*(Math.sqrt(curLen**2+this.leafDist*leaf)),
                    // this.y+Math.sin(curAng+this.angle*leaf)*(Math.sqrt(curLen**2+this.leafDist*leaf))
                    // this.x+Math.cos(curAng+this.angle*(rot-10))*(Math.sqrt(curLen**2+this.leafDist*(rot-10))),
                    // this.y+Math.sin(curAng+this.angle*(rot-10))*(Math.sqrt(curLen**2+this.leafDist*(rot-10)))
                    this.x+(i*this.rotationTrig[rot][0]-j*this.rotationTrig[rot][1])*(Math.sqrt(curLen**2+this.leafDist*(rot-10)))/curLen,
                    this.y+(i*this.rotationTrig[rot][1]+j*this.rotationTrig[rot][0])*(Math.sqrt(curLen**2+this.leafDist*(rot-10)))/curLen
                  )
                  var minDistToVerticalEdge=Math.min(gridWidth-curPos.x, curPos.x);
                  var minDistToHorizontalEdge=Math.min(gridHeight-curPos.y, curPos.y);
                  var minDistToEdge=Math.min(minDistToHorizontalEdge, minDistToVerticalEdge);

                  if (minDistToEdge>0) {//position is outside the screen, weight = 0
                    if (minDistToEdge<40/pixSize) {//current position is close to the edge of the screen, weight < 1
                      var curWeight=smootherStep(minDistToEdge/(40/pixSize));
                    }
                    else {//not close to the edge, weight = 1
                      var curWeight=1;
                    }
                    var curTotalAdd=attemptGridRead(curPos.x, curPos.y)*curWeight;// TODO: in case of 0 weight skip
                    if (!isNaN(curTotalAdd)) {
                      runningTotal+=curTotalAdd;
                      runningWeight+=curWeight;
                    }
                  }
                }
                var runningAverage=runningTotal/runningWeight;
                // attemptGridWrite(lerp(smootherStep(curLen/this.ruleSize*2), runningAverage, attemptGridRead(this.x+i, this.y+j)), this.x+i, this.y+j, newGrid)
                // attemptGridWrite(runningAverage, this.x+i, this.y+j, newGrid)
                attemptGridWrite(lerp(smootherStep(curLen/this.ruleSize*2), runningAverage, attemptGridRead(this.x+i, this.y+j)), i+this.ruleSize/2, j+this.ruleSize/2, newGrid)
                // attemptGridWrite(runningAverage, i+this.ruleSize/2, j+this.ruleSize/2, newGrid)
              }
            }
          }
          // grid=newGrid;
          // for (var i = -this.ruleSize/2; i < this.ruleSize/2; i++) {//add found values in newGrid to grid
          //   for (var j = -this.ruleSize/2; j < this.ruleSize/2; j++) {
          for (var i = this.minI; i < this.maxI; i++) {
            for (var j = this.minJ; j < this.maxJ; j++) {
              attemptGridWrite(attemptGridRead(i+this.ruleSize/2, j+this.ruleSize/2, newGrid), this.x+i, this.y+j)
              // drawPixel(this.x+i, this.y+j);// NOTE: definitely don't do this, apparently (multiple unnecessary draws slow down calculations significantly)
            }
          }
          // console.table(newGrid);
        },
        rotation: function() {
          // gridToNewGrid();
          var newGrid=[];
          for (var i = 0; i < this.ruleSize; i++) {
            newGrid[i]=[]
            for (var j = 0; j < this.ruleSize; j++) {
              newGrid[i][j]=undefined;
            }
          }

          for (var i = -this.ruleSize/2; i < this.ruleSize/2; i++) {
            for (var j = -this.ruleSize/2; j < this.ruleSize/2; j++) {
              // TODO: check if in screen bounds (?)
              if (i**2+j**2<=(this.ruleSize/2)**2) {
                var curAng=Math.atan2(j, i);
                var curLen=Math.sqrt(i**2+j**2);
                // if ((this.phase+TAU/this.sectors<=TAU)?//only do averaging for one sector
                //   (curAng>this.phase && curAng<=this.phase+TAU/this.sectors):
                //   (curAng>this.phase || curAng<=this.phase+TAU/this.sectors-TAU)
                //   ) {

                var runningTotal=0; var runningWeight=0;
                for (var sec = 0; sec < this.sectors; sec++) {
                  // var curPos=new Vec2(this.x+Math.cos(curAng+TAU*sec/this.sectors)*curLen, this.y+Math.sin(curAng+TAU*sec/this.sectors)*curLen)
                  var curPos=new Vec2(
                    this.x+i*this.rotationTrig[sec][0]-j*this.rotationTrig[sec][1],
                    this.y+i*this.rotationTrig[sec][1]+j*this.rotationTrig[sec][0]
                  )
                  var minDistToVerticalEdge=Math.min(gridWidth-curPos.x, curPos.x);
                  var minDistToHorizontalEdge=Math.min(gridHeight-curPos.y, curPos.y);
                  var minDistToEdge=Math.min(minDistToHorizontalEdge, minDistToVerticalEdge);

                  if (minDistToEdge<40/pixSize) {//current position is close to the edge of the screen, weight < 1
                    if (minDistToEdge<=0) {//position is outside the screen, weight = 0
                      var curWeight=0;
                    }
                    else {
                      var curWeight=smootherStep(minDistToEdge/(40/pixSize));
                    }
                  }
                  else {//not close to the edge, weight = 1
                    var curWeight=1;
                  }

                  var curTotalAdd=attemptGridRead(curPos.x, curPos.y)*curWeight;// TODO: in case of 0 weight skip
                  if (!isNaN(curTotalAdd)) {
                    runningTotal+=curTotalAdd;
                    runningWeight+=curWeight;
                  }
                }
                var runningAverage=runningTotal/runningWeight;
                // attemptGridWrite(lerp(smootherStep(curLen/this.ruleSize*2), runningAverage, attemptGridRead(this.x+i, this.y+j)), this.x+i, this.y+j, newGrid)
                // attemptGridWrite(runningAverage, this.x+i, this.y+j, newGrid)
                attemptGridWrite(lerp(smootherStep(curLen/this.ruleSize*2), runningAverage, attemptGridRead(this.x+i, this.y+j)), i+this.ruleSize/2, j+this.ruleSize/2, newGrid)
                // attemptGridWrite(runningAverage, i+this.ruleSize/2, j+this.ruleSize/2, newGrid)
              }
            }
          }
          // grid=newGrid;
          for (var i = -this.ruleSize/2; i < this.ruleSize/2; i++) {//add found values in newGrid to grid
            for (var j = -this.ruleSize/2; j < this.ruleSize/2; j++) {
              attemptGridWrite(attemptGridRead(i+this.ruleSize/2, j+this.ruleSize/2, newGrid), this.x+i, this.y+j)
              // drawPixel(this.x+i, this.y+j);// NOTE: definitely don't do this, apparently (multiple unnecessary draws slow down calculations significantly)
            }
          }
          // console.table(newGrid);
        }
      }
      var rules=[];

      var numRandomRules=3;
      if (false) {//random rules
        // for (var i = 0; i < 20; i++) {//make vertical mirror rules
        //   // rules.push(new Vec2(rand(gridWidth), rand(gridHeight)))
        //   rules.push({
        //     x: rand(gridWidth),
        //     y: rand(gridHeight),
        //     ruleSize: randRange(20, 50),
        //     enforce: function() {
        //       // for (var i = -this.ruleSize/2; i < this.ruleSize/2; i++) {
        //       for (var i = -this.ruleSize/2; i < 0; i++) {
        //         for (var j = -this.ruleSize/2; j < this.ruleSize/2; j++) {
        //           if (i**2+j**2<=(this.ruleSize/2)**2) {
        //             var curVal1=attemptGridRead(this.x+i, this.y+j);
        //             var curVal2=attemptGridRead(this.x-i, this.y+j);
        //             attemptGridWrite(curVal1, this.x-i, this.y+j);
        //             attemptGridWrite(curVal2, this.x+i, this.y+j);
        //           }
        //         }
        //       }
        //     }
        //   })
        // }

        // for (var i = 0; i < 10; i++) {//make bright spot rules
        //   // rules.push(new Vec2(rand(gridWidth), rand(gridHeight)))
        //   rules.push({
        //     x: rand(gridWidth),
        //     y: rand(gridHeight),
        //     ruleSize: randRange(10, 40),
        //     enforce: function() {
        //       // for (var i = -this.ruleSize/2; i < this.ruleSize/2; i++) {
        //       for (var i = -this.ruleSize/2; i < this.ruleSize/2; i++) {
        //         for (var j = -this.ruleSize/2; j < this.ruleSize/2; j++) {
        //           attemptGridWrite(1, this.x-i, this.y+j);
        //         }
        //       }
        //     }
        //   })
        // }

        // for (var i = 0; i < 7; i++) {//make rotation symmetry rules
        //   rules.push({
        //     x: (rand(0.8)+0.1)*gridWidth,
        //     y: (rand(0.8)+0.1)*gridHeight,
        //     // x: gridWidth/2,
        //     // y: gridHeight/2,
        //     // x: rand(gridWidth),
        //     // y: rand(gridHeight),
        //     // sectors: 30,
        //     // sectors: 3,
        //     sectors: Math.floor(lerp(Math.random()**2, 5, 18)),
        //     // phase: 0,
        //     ruleSize: randRange(240, 560)/pixSize,
        //     // ruleSize: canvas.height/pixSize*1.5,
        //     // ruleSize: canvas.height/pixSize,
        //     enforce: enforceFuncs.rotation
        //   })
        // }

        for (var i = 0; i < numRandomRules; i++) {//make phyllotaxis rules
          rules.push({
            // x: (rand(0.8)+0.1)*gridWidth,
            // y: (rand(0.8)+0.1)*gridHeight,
            x: gridWidth/2,
            y: gridHeight/2,
            // x: rand(gridWidth),
            // y: rand(gridHeight),
            angle: TAU*(2-PHI),
            // ruleSize: randRange(240, 560)/pixSize,
            ruleSize: canvas.height/pixSize*2,
            // ruleSize: canvas.height/pixSize,
            // leafDist: randRange(70, 200)/pixSize,
            // leafDist: 600/pixSize,
            // leafDist: 200/pixSize,
            leafDist: 70/pixSize,

            // enforce: function() {
            //   // gridToNewGrid();
            //   var newGrid=[];//optimise this too
            //   for (var i = 0; i < this.ruleSize; i++) {
            //     newGrid[i]=[]
            //     for (var j = 0; j < this.ruleSize; j++) {
            //       newGrid[i][j]=undefined;
            //     }
            //   }
            //
            //   // var minI=Math.max(-this.ruleSize/2, -this.x);
            //   // var maxI=Math.min(this.ruleSize/2, gridWidth-this.x);
            //   // var minJ=Math.max(-this.ruleSize/2, -this.y);
            //   // var maxJ=Math.min(this.ruleSize/2, gridHeight-this.y);
            //   // console.log(minI, "-", maxI, " | ", minJ, "-", maxJ);
            //
            //   for (var i = -this.ruleSize/2; i < this.ruleSize/2; i++) {
            //     for (var j = -this.ruleSize/2; j < this.ruleSize/2; j++) {
            //       // for (var i = minI; i < maxI; i++) {
            //       //   for (var j = minJ; j < maxJ; j++) {
            //       // TODO: check if in screen bounds (?)
            //       if (i**2+j**2<=(this.ruleSize/2)**2 && this.x+i>=0 && this.x+i<gridWidth+1 && this.y+j>=0 && this.y+j<gridHeight+1) {//instead find where to start and end i and j
            //         // if (i**2+j**2<=(this.ruleSize/2)**2) {
            //         // var curAng=Math.atan2(j, i)+PI;
            //         var curAng=Math.atan2(j, i);
            //         var curLen=Math.sqrt(i**2+j**2);
            //         // if ((this.phase+TAU/this.sectors<=TAU)?//only do averaging for one sector
            //         //   (curAng>this.phase && curAng<=this.phase+TAU/this.sectors):
            //         //   (curAng>this.phase || curAng<=this.phase+TAU/this.sectors-TAU)
            //         //   ) {
            //
            //         var runningTotal=0; var runningWeight=0;
            //         // for (var leaf = 0; leaf < this.sectors; leaf++) {
            //         for (var leaf = -10; leaf < 10; leaf++) {
            //           var curPos=new Vec2(
            //           this.x+Math.cos(curAng+this.angle*leaf)*(Math.sqrt(curLen**2+this.leafDist*leaf)),
            //           this.y+Math.sin(curAng+this.angle*leaf)*(Math.sqrt(curLen**2+this.leafDist*leaf))
            //           )
            //           var minDistToVerticalEdge=Math.min(gridWidth-curPos.x, curPos.x);
            //           var minDistToHorizontalEdge=Math.min(gridHeight-curPos.y, curPos.y);
            //           var minDistToEdge=Math.min(minDistToHorizontalEdge, minDistToVerticalEdge);
            //
            //           if (minDistToEdge>0) {//position is outside the screen, weight = 0
            //             if (minDistToEdge<40/pixSize) {//current position is close to the edge of the screen, weight < 1
            //               var curWeight=smootherStep(minDistToEdge/(40/pixSize));
            //             }
            //             else {//not close to the edge, weight = 1
            //               var curWeight=1;
            //             }
            //             var curTotalAdd=attemptGridRead(curPos.x, curPos.y)*curWeight;// TODO: in case of 0 weight skip
            //             if (!isNaN(curTotalAdd)) {
            //               runningTotal+=curTotalAdd;
            //               runningWeight+=curWeight;
            //             }
            //           }
            //         }
            //         var runningAverage=runningTotal/runningWeight;
            //         // attemptGridWrite(lerp(smootherStep(curLen/this.ruleSize*2), runningAverage, attemptGridRead(this.x+i, this.y+j)), this.x+i, this.y+j, newGrid)
            //         // attemptGridWrite(runningAverage, this.x+i, this.y+j, newGrid)
            //         attemptGridWrite(lerp(smootherStep(curLen/this.ruleSize*2), runningAverage, attemptGridRead(this.x+i, this.y+j)), i+this.ruleSize/2, j+this.ruleSize/2, newGrid)
            //         // attemptGridWrite(runningAverage, i+this.ruleSize/2, j+this.ruleSize/2, newGrid)
            //       }
            //     }
            //   }
            //   // grid=newGrid;
            //   for (var i = -this.ruleSize/2; i < this.ruleSize/2; i++) {//add found values in newGrid to grid
            //     for (var j = -this.ruleSize/2; j < this.ruleSize/2; j++) {
            //       attemptGridWrite(attemptGridRead(i+this.ruleSize/2, j+this.ruleSize/2, newGrid), this.x+i, this.y+j)
            //       // drawPixel(this.x+i, this.y+j);// NOTE: definitely don't do this, apparently (multiple unnecessary draws slow down calculations significantly)
            //     }
            //   }
            //   // console.table(newGrid);
            // }
            enforce: enforceFuncs.phyllotaxis
          })
        }

        // var delArr=[];
        var newPositions=[];
        // var units=50/pixSize;
        var units=140/pixSize;
        for (var i = 0; i < rules.length; i++) {//go through positions of all rules and make them push away from eachother
          newPositions[i]=new Vec2(rules[i].x, rules[i].y);
          for (var j = 0; j < rules.length; j++) {
            if (i!=j) {
              var offset=new Vec2(rules[i].x-rules[j].x, rules[i].y-rules[j].y);
              // if (offset.len()<60/pixSize) {
              //   delArr.push(i);
              // }
              newPositions[i]=newPositions[i].add(offset.unit().mult(0.5**(offset.len()/units+1)*units));
            }
          }
        }
        // rules=rules.filter(function(value, index, arr) {//remove all elements with indices present in delArr
        //   return !arrayContains(delArr, index);
        // })
        for (var i = 0; i < rules.length; i++) {//set rule positions from newPositions
          // context.fillStyle="rgb(255, 0, 0)";
          // context.fillRect(rules[i].x*pixSize, rules[i].y*pixSize, pixSize, pixSize);
          rules[i].x=newPositions[i].x;
          rules[i].y=newPositions[i].y;
          // context.fillStyle="rgb(255, 0, 255)";
          // context.fillRect(rules[i].x*pixSize, rules[i].y*pixSize, pixSize, pixSize);
        }
      }

      if (true) {//custom placed rules
        function phyllotaxisRule(x, y, size, leafDist, angle) {
          rules.push(
            ruleInitialFuncs.phyllotaxis({
              x: x*gridWidth,
              y: y*gridHeight,
              angle: angle || TAU*(2-PHI),
              ruleSize: size/pixSize || randRange(240, 560)/pixSize,
              leafDist: leafDist/pixSize || randRange(70, 200)/pixSize,
              enforce: enforceFuncs.phyllotaxis
            })
          )
        }
        // phyllotaxisRule(0.5, 0.5, 2200)
        // phyllotaxisRule(0.7, 0.2, 2100)
        // phyllotaxisRule(0.3, 0.7, 1600)
        // phyllotaxisRule(0.1, 0.7, 1700)
        // phyllotaxisRule(0.7, 0.65, 1700)

        function rotationRule(x, y, sectors, size) {
          rules.push(
            ruleInitialFuncs.rotation({
              x: x*gridWidth || (rand(0.8)+0.1)*gridWidth,
              y: y*gridHeight || (rand(0.8)+0.1)*gridHeight,
              sectors: sectors || Math.floor(lerp(Math.random()**2, 5, 18)),
              ruleSize: size/pixSize || randRange(240, 560)/pixSize,
              enforce: enforceFuncs.rotation
            })
          )
        }
        rotationRule(0.4, 0.72, 7, 1750)
        rotationRule(0.62, 0.4, 5, 2100)

        // rotationRule(0.1, 0.7, 3, 1700)
        // rotationRule(0.9, 0.65, 3, 1700)

        //pairs of odd numbers or their multiples
        // rotationRule(0.4, 0.58, 10, 1550)
        // rotationRule(0.58, 0.4, 10, 1550)
        // rotationRule(0.62, 0.3, 2, 1500)
      }
    }

    function gridOperations() {
      for (var randRuleLoops = 0; randRuleLoops < 100; randRuleLoops++) {
        var ruleChoice=rand();
        // if (true) {
        // if (false) {//make defects in monochromatic areas
        if (ruleChoice<0.03) {//make defects in monochromatic areas
          var x=rand(gridWidth);
          var y=rand(gridHeight);
          var ruleSize=lerp(Math.random()**2, 10, 80)/pixSize;
          // var ruleSize=70;
          // var ruleSize=20;
          var runningTotal=0; var runningWeight=0;
          for (var i = -ruleSize/2; i < ruleSize/2; i++) {//find current values in search area
            for (var j = -ruleSize/2; j < ruleSize/2; j++) {
              var curWeight=cutoff(Math.sqrt(i**2+j**2)/ruleSize*2, 0);
              // var curWeight=smootherStep(cutoff(Math.sqrt(i**2+j**2)/ruleSize*2, 0));//less efficient and possibly useless
              var curTotalAdd=(attemptGridRead(x+i, y+j)*2-1)*curWeight;
              if (!isNaN(curTotalAdd)) {
                runningTotal+=curTotalAdd;
                runningWeight+=curWeight;
              }
            }
          }
          var runningAverage=runningTotal/runningWeight;
          // console.log(runningTotal, "/", runningWeight, "=", runningAverage);
          var fillColor=runningTotal>0 ? 0 : 1;
          // var fillColor=0.25-runningAverage/2;
          // console.log(fillColor);
          for (var i = -ruleSize/2; i < ruleSize/2; i++) {//draw
            for (var j = -ruleSize/2; j < ruleSize/2; j++) {
              // TODO: colors are changed more when they're extreme (????? is that needed)
              attemptGridWrite(//draw on grid in fillcolor
                lerp(//lerp between background color and fillColor based on closeness
                  smootherStep(
                    cutoff(//make sure not to draw negative colors
                      1-(Math.sqrt(i**2+j**2)/ruleSize*2),//current pixel closeness to circle center (1=coindident, 0=rulesize pixels away)
                      0
                    )
                  ),
                  attemptGridRead(x+i, y+j),
                  fillColor
                ),
                x+i,
                y+j
              );
              // attemptGridWrite(1, fillColor, attemptGridRead(x+i, y+j)), x+i, y+j);
            }
          }
        }
        else if (true) {//heighten contrast in certain areas
          var x=rand(gridWidth);
          var y=rand(gridHeight);
          // var ruleSize=lerp(Math.random()**2, 200, 10)/pixSize;
          // var ruleSize=lerp(Math.random()**2, 200, 10)/pixSize;
          var ruleSize=lerp(Math.random()**2, 15, 200)/pixSize;
          // var ruleSize=70;
          // var ruleSize=20;
          var min=1; var max=0;
          for (var i = -ruleSize/2; i < ruleSize/2; i++) {//find min and max values in search area
            for (var j = -ruleSize/2; j < ruleSize/2; j++) {
              var curVal=attemptGridRead(x+i, y+j);
              if (curVal>max) max=curVal;
              if (curVal<min) min=curVal;
            }
          }
          for (var i = -ruleSize/2; i < ruleSize/2; i++) {//draw
            for (var j = -ruleSize/2; j < ruleSize/2; j++) {
              attemptGridWrite(//draw on grid in fillcolor
                lerp(//lerp between background color and fillColor based on closeness
                  smootherStep(
                    cutoff(//make sure not to draw negative colors
                      1-(Math.sqrt(i**2+j**2)/ruleSize*2),//current pixel closeness to circle center (1=coindident, 0=rulesize pixels away)
                      0
                    )
                  ),
                  attemptGridRead(x+i, y+j),
                  map(attemptGridRead(x+i, y+j), min, max, 0, 1)
                ),
                x+i,
                y+j
              );
              // attemptGridWrite(1, fillColor, attemptGridRead(x+i, y+j)), x+i, y+j);
            }
          }
        }
        // else {//mirror around vertical line
        //   var x=rand(gridWidth);
        //   var y=rand(gridHeight);
        //   var ruleSize=randRange(20, 50);
        //   for (var i = -ruleSize/2; i < 0; i++) {
        //     for (var j = -ruleSize/2; j < ruleSize/2; j++) {
        //       if (i**2+j**2<=(ruleSize/2)**2) {
        //         var curVal1=attemptGridRead(x+i, y+j);
        //         var curVal2=attemptGridRead(x-i, y+j);
        //         attemptGridWrite(curVal1, x-i, y+j);
        //         attemptGridWrite(curVal2, x+i, y+j);
        //       }
        //     }
        //   }
        // }
      }
      for (var constRuleLoops = 0; constRuleLoops < rules.length; constRuleLoops++) {// TODO: random order(?)
        rules[constRuleLoops].enforce();
      }
    }

    function draw() {
      if (!paused) {
        // if (loops% frameskip <1) {//animation
          context.clearRect(0, 0, canvas.width, canvas.height);
          for (var i = 0; i < gridWidth; i++) {
            for (var j = 0; j < gridHeight; j++) {
              drawPixel(i, j);
            }
          }
        // }
        loops++;
        // window.requestAnimationFrame(draw);
      }
    }

    function changeSeed(s) {
      globSeed=s;
      restart();
      draw();
    }
    function restart() {
      loops=0;
    }
    function resize() {
      canvas.width=window.innerWidth;
      height=canvas.height=window.innerHeight;
      restart();
    }
    initialiseGrid();
    for (var go=0; go<3; go++) {
      gridOperations();
    }
    draw();

    // canvas.addEventListener("mousemove",function(){
    //   // lastx=event.clientX;
    //   // lasty=event.clientY;
    //   var n=1;
    //   lastx=(event.clientX+lastx*n)/(n+1);
    //   lasty=(event.clientY+lasty*n)/(n+1);
    // });
    // window.addEventListener("dblclick",function(){location.reload();});
    window.addEventListener("click",function(){
      for (var allRuleLoops = 0; allRuleLoops < 1; allRuleLoops++) {
        gridOperations();
      }
      draw();
    });
    window.addEventListener("keyup",function(){
      var curKey=event.keyCode;
      keys[curKey]=false;
      // console.log(keys);
    });
    window.addEventListener("keydown",function(){
      var curKey=event.keyCode;
      keys[curKey]=true;
      // if (curKey<58 && curKey>48) {//numbers - pixsize
      //   pixSize=2**(curKey-49);
      //   // var pixSize=14;
      //   gridWidth=canvas.width/pixSize; gridHeight=canvas.height/pixSize;
      //   initialiseGrid();
      //   draw();
      // }
      // console.log(keys);
      // console.log(curKey);
      switch (curKey) {
        case 32://space - pause
          paused=!paused;
          console.log(paused?"Paused":"Unpaused");
          draw();
          break;
        case 68://d - draw
          draw();
          break;
        // case 37://left
        //   move.left();
        //   break;
      }
    });
    // window.addEventListener("resize",function(){resize();})
  </script>
</body>
</html>

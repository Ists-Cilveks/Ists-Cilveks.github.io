<!DOCTYPE html>
<html>
	<head>
		<title>TEST TEST TEST</title>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link href="/css/style.css" rel="stylesheet">
		<link href="vn.css" rel="stylesheet">
	</head>
	<body class="main-content">
	
	<script src="/js/Color.js"></script>
	<script src="/css/palettize.js"></script>
	<script src="/js/particles.js"></script>
	<script src="/js/SVGRequests.js"></script>
	
  <header id="main-header">
  </header>
  <script src="/js/languages.js" my-languges="en"></script>


  <template id="all-vn-content" style="display: none;"></template>
  
  <div id="vn-stage" onclick="progressText()" lang="en">
    <div id="vn-temp-display"></div>
    <div id="vn-textbox">
      <!-- TODO: how to handle translations? -->
      <p>Click to progress the text.</p>
    </div>
  </div>

  <script type="text/javascript">
    const textbox = document.getElementById('vn-textbox')
    const tempDisplay = document.getElementById('vn-temp-display')
    const allContent = document.getElementById('all-vn-content')
    let lastAddedContent
    let contentDiv

    const xhr = new XMLHttpRequest()
    xhr.open("GET", "test.html", true)
    xhr.responseType = "document"
    xhr.onload = function(e) {
      let myDoc = xhr.responseXML.documentElement
      allContent.appendChild(myDoc)
      contentDiv = document.getElementById("vn-content").firstElementChild
    }
    xhr.send("")

    var characters = []
    class Character {
      constructor(name, displayName, accessibleName, container, svgPath) {
        this.name = name
        this.displayName = displayName
        this.accessibleName = accessibleName
        // TODO: <span role="img" aria-label="Kit">K¡t</span>
        if (container) {
          this.container = container
        } else {
          this.container = document.createElement("div")
          this.container.className = "character-container"
          this.container.id = name+"-container"
          document.getElementById("vn-stage").appendChild(this.container)
        }
        if (svgPath) {
          insertSVG(svgPath, this.container, function(e, characterSVG) {
            characterSVG.setAttribute("height", "80vh") // FIXME: images should be scaled equally (bigger images remain bigger), instead of all being a certain height
            characterSVG.removeAttribute("width")
          })
        }
        this.expression = "neutral"
      }

      setExpression (newExp) {
        const currentExpressionID = this.name+"-"+this.expression
        const newExpressionID = this.name+"-"+newExp
        document.getElementById(currentExpressionID).style.display = "none"
        document.getElementById(newExpressionID).style.display = "inline"
        this.expression = newExp
      }
    }
    
    characters.push(new Character("kit", "K¡t", "Kit", undefined, "kit/kit.svg"))

    function takeNextElement() {
      let newContent = contentDiv.firstElementChild
      if (!newContent) {
        newContentDiv = contentDiv.nextElementSibling
        if(!newContentDiv) { // out of content
          return
        }
        contentDiv = newContentDiv
        newContent = contentDiv.firstElementChild
      }
      const classes = newContent.className.split(" ")

      // Add to appropriate place
      if (classes[0]=="vn-show-off") { // FIXME: lazy ass check, i better remember to fix this before it gives me a wild goose chase
        tempDisplay.appendChild(newContent)
      } else {
        textbox.appendChild(newContent)
      }
      lastAddedContent = newContent

      // Look for expressions
      for (const char of characters) {
        let emotion
        for (const cl of classes) {
          if (cl.startsWith(char.name+"-")) {
            emotion = cl.slice(char.name.length+1)
            break
          }
        }
        
        if (emotion) {
          char.setExpression(emotion)
        }
      }

      for (const cl of classes) {
        if (cl=="vn-take-next") {
          takeNextElement()
        }
      }
    }
    function progressText() {
      // Escape from hidden state
      if (textbox.style.display == "none") {
        textbox.style.display = "initial"
        return
      }

      // TODO: if animating text, skip to end of animation

      // TODO: how to prevent this from happening if there is no more text to show? Should I have a separate final textbox state instead of staying on the last line?
      textbox.textContent = ""
      tempDisplay.textContent = ""

      // Get next element
      takeNextElement()
    }

    document.addEventListener("keydown", function (event) {
      let key = event.key
      switch (key) {
        case "ArrowRight":
        case "Enter":
        case " ":
          progressText()
          break
      }
      key = key.toLocaleLowerCase()
      switch (key) {
        case "h":
          textbox.style.display = textbox.style.display == "none" ? "initial" : "none"
      }
    })
  </script>
	</body>
</html>